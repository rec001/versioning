<?php
/**
 * @file
 *   Callback function for customizing article.
 */

function versioning_article_init() {
  /*$vid = taxonomy_vocabulary_machine_name_load("raptor_versions")->vid;
    $terms = taxonomy_get_tree($vid);
    //print_r($terms);
    $arr = array(1 =>'200500400', 2 => '100300600',  3 => '100210300', 4 => '100200500', 5 =>'100200450', 6 => '100200400', 7 =>'000200500', 8=> '000100200');
     module_load_include('inc', 'versioning_article', 'Version.class');
    $versionClass = new Version('1.2.45');
    $min_default = $versionClass->getOlderVersion($arr);*/
    
}


/*
 * Implementing hook_menu(); 
*/
function versioning_article_menu() {
  $items = array();
  $items['node/%node/version'] = array(
    'title' => t('Node Version'),
    'description' => 'Node Version',
    'page callback' => 'nodes_versions',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}


/**
 * Implements hook_form_alter().
 */
function versioning_article_form_alter(&$form, &$form_state, $form_id) {

  $args = arg();
  if ($form_id == 'raptor_article_node_form') {
    module_load_include('inc', 'versioning_article', 'ArticleForm.class');
    $articleForm = new ArticleForm($form);
    if (!empty($args[2]) && $args[2] == 'clone') {
      // Node is being cloned.
      $articleForm->alterArticleForm(TRUE);
    }
    else {
      // Node is being inserted, and not cloned.
      $articleForm->alterArticleForm(FALSE);
    }
    $form = $articleForm->getForm();
  }

}

/**
 * Custom submit handler for the article clone form.
 *
 * If the Version field is set to Global.
 */
function versioning_article_submithandler($form, &$form_state){
	$base_article_nid = '';
	if (isset($form_state['globalredirect']['#value']) && $form_state['globalredirect']['#value']) {
		unset($_REQUEST['destination']);
    unset($form['#redirect']);
		$base_article_nid = $form_state['globalredirect']['#value'];
		$form_state['redirect'] = 'editable-versioned-articles/'.$base_article_nid;
  }
}

/**
 * Custom validate handler for the article clone form.
 *
 * If the Version field is set to Defined and both Min Version and Max Version fields are set to something other than
 * None, then make sure that Max Version > Min Version.
 */
function versioning_article_validate($form, &$form_state) {
  module_load_include('inc', 'versioning_article', 'ArticleForm.class');
  $articleForm = new ArticleForm($form, $form_state);
  $errors = $articleForm->validateArticleCloneForm();
  $form_state = $articleForm->getFormState();

  foreach ($errors as $error) {
    form_set_error($error[0], $error[1]);
  }
}


/**
 * Implements hook_node_insert().
 */
function versioning_article_node_insert($node) {

  if ($node->type != 'raptor_article') {
    return;
  }

  module_load_include('inc', 'versioning_article', 'Article.class');
  $article = new Article($node);

  $arg = arg();
  // If the current article is not being cloned, then set its base article id to be the same as its nid.
  if (!empty($arg[2]) && $arg[2] != 'clone') {
    
    // Set the base article id to be the same as the current node id.
    $article->setBaseArticleId($node->nid);

    // Save the node. This shouldn't be a recursive call since we are updating the node and not inserting it.
    $node = $article->getArticle();
    field_attach_update('node', $node);
  }

  // If the new node is published and the Version field is set to Defined then
  // Take the Min Version of the new node. Set this value to be the Max version of the node that we are cloning.
  // Save the old node. This way the Min Version of the new node = Max Version of the old node.
  if (($original_nid = $article->getCloneFromOriginalArticleId()) && ($article->getVersionField() == 'defined') &&
    $article->isPublished()
  ) {

    // Get the min version of the new node.
    $min_version_tid = $article->getMinVersionTermId();

    // Get the base node.
    $original_node = node_load($original_nid);
    $originalArticle = new Article($original_node);

    // Set the max version of the original node to be the min version of the new node.
    $originalArticle->setMaxVersionTermId($min_version_tid);
    
    // Save the original node.
    $original_node = $originalArticle->getArticle();
    node_save($original_node);
    
    
    // Set the versions of the original node while creating a clone.
    $originalArticle->getVersionsForDefined();
    
    // Save the original node.
    $original_node = $originalArticle->getArticle();
    node_save($original_node);
  }
  
  // Set the versions of the original node while creating a clone.
  if (($original_nid = $article->getCloneFromOriginalArticleId()) && ($article->getVersionField() == 'global') &&
    $article->isPublished()
  ) {
    // Get the base node.
    $original_node = node_load($original_nid);
    $originalArticle = new Article($original_node);
    
    // Set versions for base node
    $originalArticle->getVersionsForGlobal();
    
    // Save the original node.
    $original_node = $originalArticle->getArticle();
    node_save($original_node);
  }
}

/**
 * Implements hook_node_update().
 */
function versioning_article_node_update($node) {

  if ($node->type != 'raptor_article') {
    return;
  }

  module_load_include('inc', 'versioning_article', 'Article.class');
  $article = new Article($node);
  
  // If the new node is published and the Version field is set to Defined then
  // Take the Min Version of the new node. Set this value to be the Max version of the node that we are cloning.
  // Save the old node. This way the Min Version of the new node = Max Version of the old node.
  if (($original_nid = $article->getCloneFromOriginalArticleId()) && ($article->getVersionField() == 'defined') &&
    $article->isPublished()
  ) {
    
    // Get the base node.
    $original_node = node_load($original_nid);
    $originalArticle = new Article($original_node);
    
    // Set the versions of the original node while creating a clone.
    $originalArticle->getVersionsForDefined();
    
    // Save the original node.
    $original_node = $originalArticle->getArticle();
    node_save($original_node);
  }
  
  // Set the versions of the original node while creating a clone.
  if (($original_nid = $article->getCloneFromOriginalArticleId()) && ($article->getVersionField() == 'global') &&
    $article->isPublished()
  ) {
    // Get the base node.
    $original_node = node_load($original_nid);
    $originalArticle = new Article($original_node);
    
    // Set versions for base node
    $originalArticle->getVersionsForGlobal();
    
    // Save the original node.
    $original_node = $originalArticle->getArticle();
    node_save($original_node);
  }
}

/**
 * Implements hook_node_validate().
 */
function versioning_article_node_validate($node, $form, &$form_state) {
  if ($node->type != 'raptor_article') {
    return;
  }

  module_load_include('inc', 'versioning_article', 'Article.class');
  $article = new Article($node);
  
  //If the current article being saved is unpublished then don't do anything.
  //If the Version field is set to Global, then get the base article id.
  //If the base article id is not empty and is not the same as current node id, then get all the other nodes with the same base article id.
  //If there is at least one such article other than the current one, change the status of the current article to unpublished.
  //After saving the article, redirect the user to /editable-versioned-articles/%node
  $base_article_nid = '';
  if ($article->getVersionField() == 'global' && $node->status == 1) {
    if ($article->getBaseArticleId() && $article->getBaseArticleId() != $node->nid) {
			$base_article_nid = $article->isGlobalVersion();
      if ($base_article_nid) {
				
				//module_load_include('inc', 'versioning_article', 'ArticleForm.class');
        //$articleForm = new ArticleForm($form, $form_state);
				
				$form_state['globalredirect'] = array(
				  '#type' => 'value',
				  '#value' => $base_article_nid,
				);
				// unpublished current node
				$form_state['values']['status'] = 0;
			  drupal_set_message(t('A published article with global scope already exists. So we have unpublished the current article and saved it.'));
			}
    }
  }
  
  //If the current article being saved is unpublished then don't do anything.
  //If the version field is set to Defined, then get the base article id.
  //Get all the published articles who share the same base article id and whose version field is set to Defined. 
  //Exclude the article from which the current article is being cloned. 
  //Now compare the range of versions that the current article is valid vs the range of versions for which the articles obtained in step 3 are valid. 
  //Change the status of the current article to unpublished if there is a conflict in the version ranges.
  //If there is a conflict, then redirect the user to /editable-versioned-articles/ after saving the article.
  if ($article->getVersionField() == 'defined' && $node->status == 1) {
    if ($article->getBaseArticleId() && $article->getBaseArticleId() != $node->nid) {
			$base_article_nid = $article->isDefinedHasConflictVersion();
			if($base_article_nid) {
				$form_state['globalredirect'] = array(
				  '#type' => 'value',
				  '#value' => $base_article_nid,
				);
				// unpublished current node
				$form_state['values']['status'] = 0;
			  drupal_set_message(t('The version numbers of your current article conflicts with those of other articles. As a result, we have unpublished your current article.'));
      }
    }
  }
}


/**
 * Implements hook_node_presave().
 */
function versioning_article_node_presave($node) {
	if ($node->type != 'raptor_article') {
    return;
  }
  
  module_load_include('inc', 'versioning_article', 'Article.class');
  $article = new Article($node);
  
  //if the article is published and the Version field is set to Defined or Global, 
  //then find out which all versions it applies to.
  if ($node->status == 1 && $article->getVersionField() == 'defined') {
    $article->getVersionsForDefined();
  } else if ($node->status == 1 && $article->getVersionField() == 'global') {
		$article->getVersionsForGlobal();
	}
	
}


/**
 * Implements hook_block_info().
 *
 */
function versioning_article_block_info() {
	// Create an array that will hold our blocks
	$blocks = array();
	$blocks['session_redirect'] = array(
		'info' => t('Session Redirect'),
		'status' => TRUE,
    'weight' => 0,
    'region' => -1,
	);
  return $blocks;
}


/**
 * Implements hook_block_view().
 */
function versioning_article_block_view($delta = '') {
  $block = array();
	switch($delta) {
	  case 'session_redirect':
	    $block['subject'] = t('Min/Max Version');
	    $block['content'] = drupal_get_form('session_redirect');
	  break;
	}
  return $block;
}


/**
 * Implements hook_permission().
 */
function versioning_article_permission() {
  return array(
    'access raptor article' => array(
      'title' => t('Access Raptor Article'),
      'description' => t('Access Raptor Article.'),
    ),
  );
}

/**
 * Implements hook_node_access().
 */
function versioning_article_node_access($node, $op, $account){
	if(is_object($node)){
		if ($node->type != 'raptor_article') {
			return;
		}
		
		module_load_include('inc', 'versioning_article', 'Article.class');
		$article = new Article($node);
		
		//When $op = 'view' or 'update', look at the above permission. If the user has permission, then return NODE_ACCESS_ALLOW. 
		if ($node->type == 'raptor_article' && ($op == 'view' || $op == 'update')) {
				if (user_access('access raptor article')) {
					return NODE_ACCESS_ALLOW;
				} 
				//If the user does not have the above permission, then check all the versions higher than or equal to min version and lower than (not equal to) max version. 
				//If min version is set to None, then check all the versions from the lowest to one less than the max version. 
				//If max version is set to None, then check all version from min version to the highest version. 
				//If field_published of any version is checked, then return NODE_ACCESS_ALLOW. Otherwise return NODE_ACCESS_DENY.
				else if ($article->accessRaptorArticle()) {
					return NODE_ACCESS_ALLOW;
				}
				else {
					return NODE_ACCESS_DENY;  
				}
		}
	}
	// For everything else, return NODE_ACCESS_IGNORE
	return NODE_ACCESS_IGNORE;
}


/**
 * Define the form to be returned.
 *
 * Note that drupal passes in two parameters,
 * $form - which holds all of the elements of the form
 * $form_state - a special array of settings & values needed by Drupal
 */
function session_redirect($form, &$form_state) {
  $options = array();
  $vid = taxonomy_vocabulary_machine_name_load("raptor_versions")->vid;
  $terms = taxonomy_get_tree($vid);
  $default_value = '';
  
  if (sizeof ($terms) > 0){
		foreach ($terms as $term) {
			 $options[$term->tid] = $term->name;
		}
	}
	
	if(isset($_SESSION['version']['Raptor'])) {
	  $default_value = $_SESSION['version']['Raptor'];
	}
	
  $form['raptor_versions'] = array(
	  '#type' => 'select',
    '#required' => TRUE,
	  '#options' => $options,
	  '#description' => t('Please select a version.'),
	  '#default_value' => $default_value,
	);
	 
	$form['submit'] = array(
	 '#type' => 'submit',
   '#value' => t('Submit'),
	);
 
  return $form;
}


/*
 * Define a submit funciton that drupal will
 * automatically call when submit is pressed (and all validators pass)
 */
function session_redirect_submit($form, &$form_state) {
	$_SESSION['version']['Raptor'] = $form_state['values']['raptor_versions'];
}


/*
 * Menu callback
 * @para $node
 *   $node as object
 */
function nodes_versions($node) {
	if(isset($_SESSION['version']['Raptor'])) {
		module_load_include('inc', 'versioning_article', 'Article.class');
    $article = new Article($node);
    $session_redirect = $article->redirectBasedOnSession($_SESSION['version']['Raptor']);
    if($session_redirect) {
			$path = 'node/'.$session_redirect;
		  drupal_goto($path);	
		} else {
			drupal_set_message('Page not found.');
			drupal_goto();
		}
	}
}
